<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>SMLS: Make any image a seamless tile</title>
	<script src="https://cdn.jsdelivr.net/npm/file-saver@2.0.5/dist/FileSaver.min.js"></script>
	<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cropperjs@1.6.2/dist/cropper.min.css">
	<style>
		:root {
			/* Core color palette */
			--secondary: rgb(43, 55, 89);
			--primary: rgb(255, 170, 19);
			--neutral-white: rgb(255, 255, 255);
			--neutral-gray: rgb(151, 151, 151);
			
			/* Derived colors */
			--background-dark: color-mix(in srgb, var(--secondary) 70%, black);
			--text-light: var(--neutral-white);
			--container-bg: var(--secondary);
			--container-shadow: rgba(0, 0, 0, 0.3);
			--preview-bg: color-mix(in srgb, var(--neutral-gray) 30%, white);
			--grid-light: var(--neutral-gray);
			--grid-dark: color-mix(in srgb, var(--neutral-gray) 90%, black);
			--drop-zone-border: color-mix(in srgb, var(--secondary) 80%, var(--neutral-gray));
			--drop-zone-bg: color-mix(in srgb, var(--secondary) 95%, black);
			--drop-zone-hover-border: var(--primary);
			--drop-zone-hover-bg: color-mix(in srgb, var(--secondary) 70%, var(--neutral-gray));
			--button-primary-bg: var(--primary);
			--button-primary-hover-bg: color-mix(in srgb, var(--primary) 85%, black);
			--button-primary-text: var(--secondary);
			--button-disabled-bg: color-mix(in srgb, var(--secondary) 50%, var(--neutral-gray));
			--button-disabled-text: color-mix(in srgb, var(--neutral-gray) 60%, white);
			--reset-btn-bg: color-mix(in srgb, var(--secondary) 80%, var(--neutral-gray));
			--reset-btn-hover-bg: color-mix(in srgb, var(--secondary) 70%, var(--neutral-gray));
		}

		body {
			font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
			display: flex;
			flex-wrap: wrap;
			justify-content: center;
			align-items: flex-start;
			margin: 0;
			gap: 30px;
			padding: 20px;
			background-color: var(--background-dark);
			color: var(--text-light);
			line-height: 1.5;
			padding-top: 80px;
		}

		body * {
			user-select: none;
		}

		h2 {
			margin-top: 0;
		}

		.container {
			background-color: var(--container-bg);
			box-shadow: 0 4px 12px var(--container-shadow);
			padding: 20px;
			width: 100%;
			max-width: 500px;
		}

		#preview-container {
			height: 500px;
			cursor: grab;
			overflow: hidden;
			position: relative;
			background-color: var(--preview-bg);
			touch-action: none;
		}

		#preview-container:active {
			cursor: grabbing;
		}

		#preview-canvas {
			display: block;
			width: 100%;
			height: 100%;
		}

		#preview-canvas,
		.cropper-container {
			background: repeating-conic-gradient(
				var(--grid-light) 0 25%,
				var(--grid-dark) 0 50%
			) 50% / 20px 20px;
		}

		#image-to-crop {
			max-width: 100%;
			max-height: 70vh;
			display: none;
		}

		#image-to-crop.loaded {
			display: block;
		}

		#drop-zone {
			border: 2px dashed var(--drop-zone-border);
			background-color: var(--drop-zone-bg);
			color: var(--text-light);
			padding-left: 10px;
			box-sizing: border-box;
			transition: all .2s;
		}

		#drop-zone:hover {
			border-color: var(--drop-zone-hover-border);
			background-color: var(--drop-zone-hover-bg);
		}

		.controls {
			margin-top: 20px;
			display: flex;
			flex-wrap: wrap;
			gap: 10px;
			align-items: center;
		}

		#find-pattern-btn {
			margin-left: auto;
			font-size: 12px;
		}

		#crop-size-container input[type="number"] {
			width: 40px;
			padding: 8px 10px;
			border: 1px solid var(--drop-zone-border);
			background-color: var(--drop-zone-bg);
			color: var(--text-light);
			-moz-appearance: textfield;
		}
		#crop-size-container input[type="number"]::-webkit-outer-spin-button,
		#crop-size-container input[type="number"]::-webkit-inner-spin-button {
			-webkit-appearance: none;
			margin: 0;
		}

		.slider-control {
			margin-top: 20px;
		}

		.slider-control {
			display: none;
		}

		#algo-container {
			display: none;
		}

		label {
			font-weight: 600;
		}

		.slider-control label {
			display: block;
			margin-bottom: 8px;
		}

		.slider-control input[type="range"] {
			appearance: none;
			-webkit-appearance: none;
			margin: 0;
			width: 100%;
			height: 25px;
			background: var(--reset-btn-bg);
			outline: none;
		}

		.slider-control input[type="range"]::-webkit-slider-thumb {
			-webkit-appearance: none;
			appearance: none;
			width: 25px;
			height: 25px;
			background: var(--button-primary-bg);
			cursor: pointer;
		}

		.slider-control input[type="range"]::-webkit-slider-thumb:active {
			background: var(--button-primary-hover-bg);
		}

		.slider-control input[type="range"]::-moz-range-thumb:active {
			background: var(--button-primary-hover-bg);
		}

		.slider-control input[type="range"]::-moz-range-thumb {
			width: 25px;
			height: 25px;
			background: var(--button-primary-bg);
			cursor: pointer;
			border-radius: 0;
			border: none;
		}

		select {
			width: 100%;
			padding: 8px 10px;
			border: 1px solid var(--preview-bg);
			margin-top: 8px;
		}

		button {
			font-size: 14px;
			padding: 10px 16px;
			font-weight: 600;
			border: none;
			background-color: var(--button-primary-bg);
			color: var(--button-primary-text);
			cursor: pointer;
			transition: background-color 0.2s;
		}

		button:disabled {
			background-color: var(--button-disabled-bg);
			color: var(--button-disabled-text);
			cursor: not-allowed;
		}

		button:hover:not(:disabled) {
			background-color: var(--button-primary-hover-bg);
		}

		#reset-btn {
			background-color: var(--reset-btn-bg);
			color: var(--text-light);
		}

		#reset-btn:hover:not(:disabled) {
			background-color: var(--reset-btn-hover-bg);
		}

		/* Header styles */
		header {
			position: absolute;
			top: 0;
			left: 0;
			right: 0;
			height: 60px;
			background-color: var(--container-bg);
			box-shadow: 0 2px 8px var(--container-shadow);
			display: flex;
			align-items: center;
			justify-content: space-between;
			padding: 0 20px;
			z-index: 1000;
		}

		.header-left {
			display: flex;
			align-items: center;
			gap: 12px;
		}

		.logo {
			width: 40px;
			height: 40px;
			background: url('logo.svg') center/contain no-repeat;
			background-color: var(--secondary);
			padding: 5px;
			border-radius: 4px;
			flex-shrink: 0;
		}

		.app-title {
			font-size: 18px;
			line-height: 1.2;
			font-weight: 600;
			color: var(--text-light);
			margin: 0;
		}

		.header-right {
			color: var(--neutral-gray);
			font-size: 14px;
		}

		.header-right span:first-child::after {
			content: " | ";
		}

		.header-right a {
			color: var(--primary);
			text-decoration: none;
		}

		.header-right a:hover {
			text-decoration: underline;
		}

		@media(max-width: 720px) {
			body {
				padding: 75px 0 0 0;
			}

			h2 {
				font-size: 18px;
			}

			header {
				padding: 0 7px;
			}

			.header-left {
				gap: 8px;
				width: 60%;
			}

			.logo {
				width: 30px;
				height: 30px;
			}
			.app-title {
				font-size: 16px;
			}

			.subtitle {
				font-size: 12px;
				display: block;
			}

			.header-right {
				font-size: 12px;
			}

			.header-right span {
				display: block;
			}

			.header-right span::after {
				display: none;
			}

			.container {
				padding: 15px;
				max-width: 100%;
			}
		}

		@media(max-width: 420px) {
			#find-pattern-btn {
				margin-left: 0;
				margin-right: 50%;
			}			
		}
	</style>
</head>

<body>
	<header>
		<div class="header-left">
			<div class="logo"></div>
			<h1 class="app-title">SMLS: <span class="subtitle">Make any image a&nbsp;seamless&nbsp;tile</span></h1>
		</div>
		<div class="header-right">
			<span>Made by <a href="https://baegus.cz" target="_blank">Baegus</a></span>
			<span>Star on <a href="https://github.com/Baegus/SMLS" target="_blank">GitHub</a></span>
		</div>
	</header>

	<div id="editor-container" class="container">
		<h2>Upload & Crop Image</h2>
		<div id="drop-zone">
			<p>Drag & Drop your image anywhere or click&nbsp;here</p>
			<input type="file" id="image-input" accept="image/*" style="display: none;">
		</div>
		
		<div><img id="image-to-crop" alt="Source image for cropping"></div>
		
		<div id="crop-size-container" class="controls" style="display: none;">
			<input type="number" id="crop-width-input" min="1">
			<span>Ã—</span>
			<input type="number" id="crop-height-input" min="1">
			<span> px</span>
			<button id="find-pattern-btn" title="Automatically find repeating pattern size">Auto-Find Pattern</button>
		</div>
		
		<div id="algo-container" class="controls">
			<label for="blend-mode">Blend Algorithm</label>
			<select id="blend-mode">
				<option value="perlin" selected>Perlin Noise</option>
				<option value="wavy">Wavy gradient</option>
				<option value="linear">Linear gradient</option>
			</select>
		</div>

		<div id="blend-slider-container" class="slider-control">
			<label for="blend-amount">Blend Amount: <span id="blend-value">16</span>%</label>
			<input type="range" id="blend-amount" min="0" max="100" value="16">
		</div>

		<div id="waviness-container" class="slider-control">
			<label for="waviness">Waviness: <span id="waviness-value">35</span>%</label>
			<input type="range" id="waviness" min="0" max="100" value="35">
		</div>

		<div id="perlin-scale-container" class="slider-control">
			<label for="perlin-scale">Noise Scale: <span id="perlin-scale-value">20</span>%</label>
			<input type="range" id="perlin-scale" min="1" max="100" value="20">
		</div>

		<div id="perlin-octaves-container" class="slider-control">
			<label for="perlin-octaves">Noise Detail (Octaves): <span id="perlin-octaves-value">3</span></label>
			<input type="range" id="perlin-octaves" min="1" max="8" value="3">
		</div>


		<div class="controls">
			<button id="download-btn" disabled>Download Tile (PNG)</button>
			<button id="reset-btn" style="display: none;">Try another image</button>
		</div>
	</div>

	<div class="container">
		<h2>Preview (Pan & Zoom)</h2>
		<div id="preview-container">
			<canvas id="preview-canvas"></canvas>
		</div>
		<div class="controls">
			<label>
				<input type="checkbox" id="show-transitions">
				Show transitions only
			</label>
		</div>
	</div>

	<script src="https://cdn.jsdelivr.net/npm/cropperjs@1.6.2/dist/cropper.min.js"></script>
	<script>
		function debounce(func, getWait) {
			let timeout;
			return function executedFunction(...args) {
				const later = () => {
					clearTimeout(timeout);
					func(...args);
				};
				clearTimeout(timeout);
				const wait = typeof getWait === "function" ? getWait() : getWait;
				timeout = setTimeout(later, wait);
			};
		}
		// --- PERLIN NOISE GENERATOR ---
		// Based on implementation by Ken Perlin
		class PerlinNoise {
			constructor() {
				this.p = new Uint8Array(512);
				const permutation = [151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140, 36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23, 190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117, 35, 11, 32, 57, 177, 33, 88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175, 74, 165, 71, 134, 139, 48, 27, 166, 77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133, 230, 220, 105, 92, 41, 55, 46, 245, 40, 244, 102, 143, 54, 65, 25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89, 18, 169, 200, 196, 135, 130, 116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226, 250, 124, 123, 5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17, 182, 189, 28, 42, 223, 183, 170, 213, 119, 248, 152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9, 129, 22, 39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246, 97, 228, 254, 138, 1, 107, 205, 4, 195, 121, 115, 210, 51, 14, 162, 34, 215, 150, 156, 128, 141, 180, 181, 114, 193, 214, 199, 192, 106, 72, 127, 176, 238, 239, 184, 249, 67, 12, 145, 24, 236, 222, 191, 144, 157, 66, 235, 49, 61, 179, 81, 93, 243, 204, 241, 78, 242, 12, 31, 50];
				for (let i = 0; i < 256; i++) this.p[i] = this.p[i + 256] = permutation[i];
			}
			noise(x, y, z = 0) {
				let X = Math.floor(x) & 255,
					Y = Math.floor(y) & 255,
					Z = Math.floor(z) & 255;
				x -= Math.floor(x); y -= Math.floor(y); z -= Math.floor(z);
				let u = this.fade(x), v = this.fade(y), w = this.fade(z);
				let A = this.p[X] + Y,
					AA = this.p[A] + Z,
					AB = this.p[A + 1] + Z,
					B = this.p[X + 1] + Y,
					BA = this.p[B] + Z,
					BB = this.p[B + 1] + Z;
				return this.lerp(w, this.lerp(v, this.lerp(u, this.grad(this.p[AA], x, y, z), this.grad(this.p[BA], x - 1, y, z)),
					this.lerp(u, this.grad(this.p[AB], x, y - 1, z), this.grad(this.p[BB], x - 1, y - 1, z))),
					this.lerp(v, this.lerp(u, this.grad(this.p[AA + 1], x, y, z - 1),
						this.grad(this.p[BA + 1], x - 1, y, z - 1)),
						this.lerp(u, this.grad(this.p[AB + 1], x, y - 1, z - 1), this.grad(this.p[BB + 1], x - 1, y - 1, z - 1))));
			}
			fade(t) { return t * t * t * (t * (t * 6 - 15) + 10); }
			lerp(t, a, b) { return a + t * (b - a); }
			grad(hash, x, y, z) {
				let h = hash & 15;
				let u = h < 8 ? x : y, v = h < 4 ? y : h === 12 || h === 14 ? x : z;
				return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
			}
		}
		const perlin = new PerlinNoise();


		// DOM Elements
		const dropZone = document.getElementById("drop-zone");
		const imageInput = document.getElementById("image-input");
		const imageToCrop = document.getElementById("image-to-crop");
		const downloadBtn = document.getElementById("download-btn");
		const resetBtn = document.getElementById("reset-btn");
		const previewCanvas = document.getElementById("preview-canvas");
		const previewCtx = previewCanvas.getContext("2d");
		const showTransitionsCheckbox = document.getElementById("show-transitions");

		const algoContainer = document.getElementById("algo-container");
		const blendModeSelect = document.getElementById("blend-mode");
		const blendSliderContainer = document.getElementById("blend-slider-container");
		const blendSlider = document.getElementById("blend-amount");
		const blendValueSpan = document.getElementById("blend-value");
		const wavinessContainer = document.getElementById("waviness-container");
		const wavinessSlider = document.getElementById("waviness");
		const wavinessValueSpan = document.getElementById("waviness-value");
		const perlinScaleContainer = document.getElementById("perlin-scale-container");
		const perlinScaleSlider = document.getElementById("perlin-scale");
		const perlinScaleValueSpan = document.getElementById("perlin-scale-value");
		const perlinOctavesContainer = document.getElementById("perlin-octaves-container");
		const perlinOctavesSlider = document.getElementById("perlin-octaves");
		const perlinOctavesValueSpan = document.getElementById("perlin-octaves-value");
		const cropSizeContainer = document.getElementById("crop-size-container");
		const cropWidthInput = document.getElementById("crop-width-input");
		const cropHeightInput = document.getElementById("crop-height-input");


		// ---- State
		let cropper, finalTileCanvas, transitionOnlyCanvas, sourceImage;
		let transform = { x: 0, y: 0, zoom: 1 };
		let isPanning = false;
		let lastMousePos = { x: 0, y: 0 };
		let initialPinchDistance = null;
		let uploadedFileName = 'image';
		let currentObjectUrl = null;

		// --- Event Listeners ---
		dropZone.addEventListener("click", () => imageInput.click());
		dropZone.addEventListener("dragover", e => {
			e.preventDefault();
			dropZone.style.borderColor = "#0052cc";
		});
		dropZone.addEventListener("dragleave", () => {
			dropZone.style.borderColor = "#dfe1e6";
		});
		dropZone.addEventListener("drop", e => {
			e.preventDefault();
			e.stopPropagation(); // Prevent window handler from firing too
			dropZone.style.borderColor = "#dfe1e6";
			if (e.dataTransfer.files.length) handleFile(e.dataTransfer.files[0]);
		});
		imageInput.addEventListener("change", e => {
			if (e.target.files.length) handleFile(e.target.files[0]);
		});

		// Make the entire page a drop zone
		window.addEventListener("dragover", e => {
			e.preventDefault();
		});

		window.addEventListener("drop", e => {
			e.preventDefault();
			if (e.dataTransfer.files && e.dataTransfer.files.length > 0) {
				handleFile(e.dataTransfer.files[0]);
			}
		});

		const handleSizeInputChange = () => {
			if (!cropper || !sourceImage) return;
			const newWidth = parseInt(cropWidthInput.value, 10);
			const newHeight = parseInt(cropHeightInput.value, 10);

			if (isNaN(newWidth) || isNaN(newHeight) || newWidth <= 0 || newHeight <= 0) {
				return; // Don't set invalid data
			}

			// Clamp the width and height to the source image dimensions
			const clampedWidth = Math.min(newWidth, sourceImage.naturalWidth);
			const clampedHeight = Math.min(newHeight, sourceImage.naturalHeight);
			cropWidthInput.value = clampedWidth;
			cropHeightInput.value = clampedHeight;

			cropper.setData({
				width: clampedWidth,
				height: clampedHeight
			});
		};
		const debouncedSizeChange = debounce(handleSizeInputChange, 300);
		cropWidthInput.addEventListener('input', debouncedSizeChange);
		cropHeightInput.addEventListener('input', debouncedSizeChange);

		let megapixels = 0;
		const debouncedGenerateTexture = debounce(generateSeamlessTexture, () => {
			// Dynamic debounce delay based on image size
			if (!sourceImage) return 200; // default fallback
			if (megapixels < 1) return 10;
			if (megapixels < 4) return 100;
			return 300;
		});

		const handleParamChange = () => debouncedGenerateTexture();
		blendSlider.addEventListener("input", () => {
			blendValueSpan.textContent = blendSlider.value;
			handleParamChange();
		});
		wavinessSlider.addEventListener("input", () => {
			wavinessValueSpan.textContent = wavinessSlider.value;
			handleParamChange();
		});
		perlinScaleSlider.addEventListener("input", () => {
			perlinScaleValueSpan.textContent = perlinScaleSlider.value;
			handleParamChange();
		});
		perlinOctavesSlider.addEventListener("input", () => {
			perlinOctavesValueSpan.textContent = perlinOctavesSlider.value;
			handleParamChange();
		});


		blendModeSelect.addEventListener("change", () => {
			const mode = blendModeSelect.value;
			wavinessContainer.style.display = mode === "wavy" ? "block" : "none";
			perlinScaleContainer.style.display = mode === "perlin" ? "block" : "none";
			perlinOctavesContainer.style.display = mode === "perlin" ? "block" : "none";
			generateSeamlessTexture();
		});

		downloadBtn.addEventListener("click", () => {
			if (!finalTileCanvas) return;
			const fileName = `SMLS_${finalTileCanvas.width}x${finalTileCanvas.height}_${uploadedFileName}.png`;
			finalTileCanvas.toBlob(function (blob) {
				saveAs(blob, fileName);
			}, "image/png");
		});

		resetBtn.addEventListener("click", () => {
			if (confirm("Are you sure you want to discard the current image?")) {
				resetTool();
			}
		});


		// ---- Preview controls (Mouse)
		previewCanvas.addEventListener("wheel", handleZoom, { passive: false });
		previewCanvas.addEventListener("mousedown", e => {
			isPanning = true;
			lastMousePos = { x: e.clientX, y: e.clientY };
		});
		previewCanvas.addEventListener("mousemove", e => {
			if (!isPanning) return;
			const dx = e.clientX - lastMousePos.x, dy = e.clientY - lastMousePos.y;
			transform.x += dx;
			transform.y += dy;
			lastMousePos = { x: e.clientX, y: e.clientY };
			drawPreview();
		});
		previewCanvas.addEventListener("mouseup", () => isPanning = false);
		previewCanvas.addEventListener("mouseleave", () => isPanning = false);

		// ---- Preview controls (Touch)
		previewCanvas.addEventListener("touchstart", e => {
			e.preventDefault();
			if (e.touches.length === 1) {
				isPanning = true;
				lastMousePos = { x: e.touches[0].clientX, y: e.touches[0].clientY };
			} else if (e.touches.length === 2) {
				isPanning = false; // Stop panning for pinch
				const dx = e.touches[0].clientX - e.touches[1].clientX;
				const dy = e.touches[0].clientY - e.touches[1].clientY;
				initialPinchDistance = Math.sqrt(dx * dx + dy * dy);
			}
		}, { passive: false });

		previewCanvas.addEventListener("touchmove", e => {
			e.preventDefault();
			if (e.touches.length === 1 && isPanning) {
				// Pan (1 finger)
				const touch = e.touches[0];
				const dx = touch.clientX - lastMousePos.x;
				const dy = touch.clientY - lastMousePos.y;
				transform.x += dx;
				transform.y += dy;
				lastMousePos = { x: touch.clientX, y: touch.clientY };
				drawPreview();
			} else if (e.touches.length === 2 && initialPinchDistance) {
				// Pinch to Zoom (2 fingers)
				const dx = e.touches[0].clientX - e.touches[1].clientX;
				const dy = e.touches[0].clientY - e.touches[1].clientY;
				const currentDistance = Math.sqrt(dx * dx + dy * dy);
				const scale = currentDistance / initialPinchDistance;

				const rect = previewCanvas.getBoundingClientRect();
				const midX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
				const midY = (e.touches[0].clientY + e.touches[1].clientY) / 2;
				const mX = midX - rect.left;
				const mY = midY - rect.top;

				const oZ = transform.zoom;
				transform.zoom *= scale;
				transform.zoom = Math.max(0.1, Math.min(10, transform.zoom));

				transform.x = mX - (mX - transform.x) * (transform.zoom / oZ);
				transform.y = mY - (mY - transform.y) * (transform.zoom / oZ);

				initialPinchDistance = currentDistance;
				drawPreview();
			}
		}, { passive: false });

		previewCanvas.addEventListener("touchend", e => {
			if (e.touches.length < 2) {
				initialPinchDistance = null;
			}
			if (e.touches.length < 1) {
				isPanning = false;
			}
			// If a pinch ends and one finger remains, start panning from that finger's position
			if (e.touches.length === 1) {
				isPanning = true;
				lastMousePos = { x: e.touches[0].clientX, y: e.touches[0].clientY };
			}
		});


		window.addEventListener("resize", drawPreview);
		showTransitionsCheckbox.addEventListener("change", drawPreview);


		function handleZoom(e) {
			e.preventDefault();
			const scale = 1.1;
			const rect = previewCanvas.getBoundingClientRect();
			const mX = e.clientX - rect.left, mY = e.clientY - rect.top;
			const oZ = transform.zoom;
			transform.zoom *= (e.deltaY < 0 ? scale : 1 / scale);
			transform.zoom = Math.max(0.1, Math.min(10, transform.zoom));
			transform.x = mX - (mX - transform.x) * (transform.zoom / oZ);
			transform.y = mY - (mY - transform.y) * (transform.zoom / oZ);
			drawPreview();
		}

		function handleFile(file) {
			if (!file.type.startsWith("image/")) return;

			// Revoke the old object URL to free up memory
			if (currentObjectUrl) {
				URL.revokeObjectURL(currentObjectUrl);
			}

			// Store filename for download
			uploadedFileName = file.name.replace(/\.[^/.]+$/, "");

			// Create a new object URL for the uploaded file
			currentObjectUrl = URL.createObjectURL(file);

			imageToCrop.classList.remove("loaded");
			sourceImage = new Image();
			sourceImage.onload = () => {
				imageToCrop.src = currentObjectUrl;
				dropZone.style.display = "none";
				cropSizeContainer.style.display = "flex";
				algoContainer.style.display = "block";
				blendSliderContainer.style.display = "block";
				// Show correct sliders for default mode
				const mode = blendModeSelect.value;
				wavinessContainer.style.display = mode === "wavy" ? "block" : "none";
				perlinScaleContainer.style.display = mode === "perlin" ? "block" : "none";
				perlinOctavesContainer.style.display = mode === "perlin" ? "block" : "none";
				downloadBtn.disabled = false;
				resetBtn.style.display = "block";

				if (cropper) cropper.destroy();
				cropper = new Cropper(imageToCrop, {
					viewMode: 1,
					background: false,
					zoomable: false,
					crop: () => {
						const data = cropper.getData({ rounded: true });
						// Update inputs ONLY if they are not the active element to prevent loops
						if (document.activeElement !== cropWidthInput && document.activeElement !== cropHeightInput) {
							cropWidthInput.value = data.width;
							cropHeightInput.value = data.height;
						}
						debouncedGenerateTexture();
					},
					ready: function () {
						this.cropper.setData({
							x: 0,
							y: 0,
							width: sourceImage.naturalWidth * 0.9,
							height: sourceImage.naturalHeight * 0.9,
						});
					}
				});
				imageToCrop.classList.add("loaded");
				megapixels = (sourceImage.naturalWidth * sourceImage.naturalHeight) / 1_000_000;
			};
			sourceImage.src = currentObjectUrl;
		}

		function resetTool() {
			// Destroy cropper
			if (cropper) {
				cropper.destroy();
				cropper = null;
			}

			// Reset DOM visibility
			imageToCrop.src = "";
			imageToCrop.classList.remove("loaded");
			dropZone.style.display = "block";

			// Hide all sliders and algo selector
			cropSizeContainer.style.display = "none";
			algoContainer.style.display = "none";
			blendSliderContainer.style.display = "none";
			wavinessContainer.style.display = "none";
			perlinScaleContainer.style.display = "none";
			perlinOctavesContainer.style.display = "none";

			// Reset button states
			downloadBtn.disabled = true;
			resetBtn.style.display = "none";

			// Clear preview
			if (previewCanvas.width > 0 && previewCanvas.height > 0) {
				previewCtx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
			}

			if (currentObjectUrl) {
				URL.revokeObjectURL(currentObjectUrl);
			}

			// Reset state variables
			finalTileCanvas = null;
			transitionOnlyCanvas = null;
			sourceImage = null;
			currentObjectUrl = null;
			uploadedFileName = "image";
			transform = { x: 0, y: 0, zoom: 1 };

			// Allow re-uploading the same file
			imageInput.value = null;
		}

		// --- Automatic Pattern Detection ---

		const findBtn = document.getElementById('find-pattern-btn');
		/**
		 * Kicks off the two-pass (coarse and fine) pattern detection process.
		 */
		async function findBestCrop() {
			if (!sourceImage || !cropper) return;

			if (megapixels > 4) {
				if (!confirm("The image is quite large and automatic pattern detection may take a while. Do you want to proceed?")) {
					return;
				}
			}
			
			const originalText = findBtn.innerHTML;
			findBtn.disabled = true;
			findBtn.innerHTML = 'Analyzing...';

			await new Promise(resolve => setTimeout(resolve, 10)); // Allow UI to update

			// --- Create Grayscale Data (both low-res and full-res) ---
			const MAX_DIM = 256;
			const MIN_CROP_FACTOR = 0.5;

			// Low-res canvas for coarse search
			const coarseCanvas = document.createElement('canvas');
			const coarseCtx = coarseCanvas.getContext('2d', { willReadFrequently: true });
			const scale = Math.min(1, MAX_DIM / sourceImage.naturalWidth, MAX_DIM / sourceImage.naturalHeight);
			const coarseW = Math.round(sourceImage.naturalWidth * scale);
			const coarseH = Math.round(sourceImage.naturalHeight * scale);
			coarseCanvas.width = coarseW;
			coarseCanvas.height = coarseH;
			coarseCtx.drawImage(sourceImage, 0, 0, coarseW, coarseH);
			const coarseGrayData = getGrayscaleData(coarseCtx, coarseW, coarseH);

			// Full-res canvas for fine search
			const fullCanvas = document.createElement('canvas');
			const fullCtx = fullCanvas.getContext('2d', { willReadFrequently: true });
			const fullW = sourceImage.naturalWidth;
			const fullH = sourceImage.naturalHeight;
			fullCanvas.width = fullW;
			fullCanvas.height = fullH;
			fullCtx.drawImage(sourceImage, 0, 0, fullW, fullH);
			const fullGrayData = getGrayscaleData(fullCtx, fullW, fullH);

			const targetWidth = coarseW * MIN_CROP_FACTOR;
			const targetHeight = coarseH * MIN_CROP_FACTOR;

			const { periodX, periodY } = findPeriodicity(
				coarseGrayData, coarseW, coarseH, targetWidth, targetHeight,
				fullGrayData, fullW, fullH, scale
			);

			if (periodX > 10 && periodY > 10) {
				const currentData = cropper.getData();
				cropper.setData({
					...currentData,
					width: periodX,
					height: periodY,
				});
			} else {
				alert("Could not automatically detect a repeating pattern. Please select the crop area manually.");
			}

			findBtn.disabled = false;
			findBtn.innerHTML = originalText;
		}

		/**
		 * Helper function to convert canvas context to a grayscale Uint8Array.
		 */
		function getGrayscaleData(ctx, width, height) {
			const imageData = ctx.getImageData(0, 0, width, height);
			const data = imageData.data;
			const grayData = new Uint8Array(width * height);
			for (let i = 0; i < data.length; i += 4) {
				const gray = 0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2];
				grayData[i / 4] = gray;
			}
			return grayData;
		}

		/**
		 * Performs a two-pass search for the pattern period.
		 */
		function findPeriodicity(coarseGray, coarseW, coarseH, targetX, targetY, fullGray, fullW, fullH, scale) {
			const minShift = 10;

			// --- Pass 1: Coarse search on downscaled image ---
			const estimateX = findBestShift(coarseGray, coarseW, coarseH, 'horizontal', targetX, minShift);
			const estimateY = findBestShift(coarseGray, coarseW, coarseH, 'vertical', targetY, minShift);

			// Scale up the estimate to full resolution dimensions
			const scaledEstimateX = Math.round(estimateX / scale);
			const scaledEstimateY = Math.round(estimateY / scale);

			// --- Pass 2: Fine search on full-resolution image around the estimate ---
			const searchRadius = 30; // Search +/- 30px around the estimate. Should be larger than the error.

			const fineTargetX = Math.max(minShift, scaledEstimateX - searchRadius);
			const periodX = findBestShift(fullGray, fullW, fullH, 'horizontal', fineTargetX, minShift, scaledEstimateX + searchRadius);

			const fineTargetY = Math.max(minShift, scaledEstimateY - searchRadius);
			const periodY = findBestShift(fullGray, fullW, fullH, 'vertical', fineTargetY, minShift, scaledEstimateY + searchRadius);

			return { periodX, periodY };
		}

		/**
		 * Core logic to calculate Sum of Absolute Differences (SAD) and find the best shift.
		 */
		function findBestShift(grayData, width, height, direction, targetSize, minShift, searchEnd = null) {
			const searchLimit = searchEnd || Math.floor((direction === 'horizontal' ? width : height) * 0.95);

			const sadScores = [];
			for (let shift = minShift; shift < searchLimit; shift++) {
				let sumDiff = 0;
				if (direction === 'horizontal') {
					for (let y = 0; y < height; y += 4) { // Sample rows for speed
						for (let x = 0; x < width - shift; x++) {
							const idx1 = y * width + x;
							const idx2 = idx1 + shift;
							sumDiff += Math.abs(grayData[idx1] - grayData[idx2]);
						}
					}
				} else { // vertical
					for (let x = 0; x < width; x += 4) { // Sample columns for speed
						for (let y = 0; y < height - shift; y++) {
							const idx1 = y * width + x;
							const idx2 = idx1 + (shift * width);
							sumDiff += Math.abs(grayData[idx1] - grayData[idx2]);
						}
					}
				}
				sadScores.push({ shift, score: sumDiff });
			}

			if (sadScores.length === 0) return 0;

			// If it's a fine search (searchEnd is defined), just find the absolute best score.
			if (searchEnd !== null) {
				return sadScores.reduce((min, p) => p.score < min.score ? p : min, sadScores[0]).shift;
			}

			// Otherwise, it's a coarse search. Find local minima and prefer larger sizes.
			const localMinima = [];
			for (let i = 1; i < sadScores.length - 1; i++) {
				if (sadScores[i].score < sadScores[i - 1].score && sadScores[i].score < sadScores[i + 1].score) {
					localMinima.push(sadScores[i].shift);
				}
			}

			if (localMinima.length > 0) {
				const candidates = localMinima.filter(p => p >= targetSize);
				if (candidates.length > 0) {
					return candidates[0]; // Smallest period that meets the size requirement
				}
				return localMinima[localMinima.length - 1]; // Fallback to largest found period
			}

			// Absolute fallback: global minimum if no local ones were found
			return sadScores.reduce((min, p) => p.score < min.score ? p : min, sadScores[0]).shift;
		}

		findBtn.addEventListener('click', findBestCrop);

		// ---- Tile generation
		function generateSeamlessTexture() {
			if (!cropper || !sourceImage) return;

			// Use Cropper's natural-size coordinates directly.
			const cropData = cropper.getData({ rounded: true });

			let sx = Math.max(0, Math.round(cropData.x));
			let sy = Math.max(0, Math.round(cropData.y));
			let sWidth = Math.max(1, Math.round(cropData.width));
			let sHeight = Math.max(1, Math.round(cropData.height));

			// Clamp to image bounds to avoid sampling outside the source.
			sWidth = Math.min(sWidth, sourceImage.naturalWidth - sx);
			sHeight = Math.min(sHeight, sourceImage.naturalHeight - sy);

			finalTileCanvas = document.createElement("canvas");
			finalTileCanvas.width = sWidth;
			finalTileCanvas.height = sHeight;
			const tileCtx = finalTileCanvas.getContext("2d");

			transitionOnlyCanvas = document.createElement("canvas");
			transitionOnlyCanvas.width = sWidth;
			transitionOnlyCanvas.height = sHeight;
			const transCtx = transitionOnlyCanvas.getContext("2d");

			// Base crop
			tileCtx.drawImage(sourceImage, sx, sy, sWidth, sHeight, 0, 0, sWidth, sHeight);

			const blendRatio = blendSlider.value / 100;
			if (blendRatio === 0) {
				drawPreview();
				return;
			}

			// Calculate available "excess" pixels on all sides
			const leftExcess = sx;
			const rightExcess = sourceImage.naturalWidth - (sx + sWidth);
			const topExcess = sy;
			const bottomExcess = sourceImage.naturalHeight - (sy + sHeight);

			const horizSide = rightExcess >= leftExcess ? "right" : "left";   // which side we borrow from
			const vertSide = bottomExcess >= topExcess ? "bottom" : "top";

			let blendW = 0, blendH = 0, didHoriz = false, didVert = false;

			// helper: edge patch
			const createAndBlendPatch = (sx_, sy_, w_, h_, dx_, dy_, edge) => {
				if (w_ <= 0 || h_ <= 0) return;
				const patch = document.createElement("canvas");
				patch.width = w_;
				patch.height = h_;
				const pctx = patch.getContext("2d");
				pctx.drawImage(sourceImage, sx_, sy_, w_, h_, 0, 0, w_, h_);
				pctx.globalCompositeOperation = "destination-in";

				const mode = blendModeSelect.value;
				if (mode === "wavy") {
					pctx.drawImage(buildWavyMaskCanvas(w_, h_, edge), 0, 0);
				} else if (mode === "perlin") {
					pctx.drawImage(buildPerlinMaskCanvas(w_, h_, edge), 0, 0);
				} else {
					drawLinearMask(pctx, w_, h_, edge);
				}
				pctx.globalCompositeOperation = "source-over";
				tileCtx.drawImage(patch, dx_, dy_);
				transCtx.drawImage(patch, dx_, dy_);
			};

			// horizontal seam
			if (horizSide === "right" && rightExcess > 0) {
				blendW = Math.floor(Math.min(rightExcess, sWidth / 2) * blendRatio);
				if (blendW > 0) {
					createAndBlendPatch(sx + sWidth, sy, blendW, sHeight, 0, 0, "left");
					didHoriz = true;
				}
			} else if (horizSide === "left" && leftExcess > 0) {
				blendW = Math.floor(Math.min(leftExcess, sWidth / 2) * blendRatio);
				if (blendW > 0) {
					createAndBlendPatch(sx - blendW, sy, blendW, sHeight, sWidth - blendW, 0, "right");
					didHoriz = true;
				}
			}

			// vertical seam
			if (vertSide === "bottom" && bottomExcess > 0) {
				blendH = Math.floor(Math.min(bottomExcess, sHeight / 2) * blendRatio);
				if (blendH > 0) {
					createAndBlendPatch(sx, sy + sHeight, sWidth, blendH, 0, 0, "top");
					didVert = true;
				}
			} else if (vertSide === "top" && topExcess > 0) {
				blendH = Math.floor(Math.min(topExcess, sHeight / 2) * blendRatio);
				if (blendH > 0) {
					createAndBlendPatch(sx, sy - blendH, sWidth, blendH, 0, sHeight - blendH, "bottom");
					didVert = true;
				}
			}

			if (didHoriz && didVert && blendW > 0 && blendH > 0) {
				const corner = document.createElement("canvas");
				corner.width = blendW;
				corner.height = blendH;
				const cctx = corner.getContext("2d");

				// choose diagonal source + destination + which corner
				let srcX, srcY, dstX, dstY, which;
				if (horizSide === "right" && vertSide === "bottom") { // top-left corner uses BR source
					srcX = sx + sWidth;
					srcY = sy + sHeight;
					dstX = 0;
					dstY = 0;
					which = "tl";
				} else if (horizSide === "right" && vertSide === "top") { // bottom-left corner uses TR source
					srcX = sx + sWidth;
					srcY = sy - blendH;
					dstX = 0;
					dstY = sHeight - blendH;
					which = "bl";
				} else if (horizSide === "left" && vertSide === "bottom") { // top-right corner uses BL source
					srcX = sx - blendW;
					srcY = sy + sHeight;
					dstX = sWidth - blendW;
					dstY = 0;
					which = "tr";
				} else { // left & top -> bottom-right corner uses TL source
					srcX = sx - blendW;
					srcY = sy - blendH;
					dstX = sWidth - blendW;
					dstY = sHeight - blendH;
					which = "br";
				}

				cctx.drawImage(sourceImage, srcX, srcY, blendW, blendH, 0, 0, blendW, blendH);
				cctx.globalCompositeOperation = "destination-in";
				const mode = blendModeSelect.value;
				if (mode === "wavy") {
					cctx.drawImage(buildWavyCornerMaskCanvas(blendW, blendH, which, sWidth, sHeight, dstX, dstY), 0, 0);
				} else if (mode === "perlin") {
					cctx.drawImage(buildPerlinCornerMaskCanvas(blendW, blendH, which, sWidth, sHeight, dstX, dstY), 0, 0);
				} else {
					drawCornerLinearMask(cctx, blendW, blendH, which);
				}
				cctx.globalCompositeOperation = "source-over";
				tileCtx.drawImage(corner, dstX, dstY);
				transCtx.drawImage(corner, dstX, dstY);
			}

			drawPreview();
		}

		// ---- Mask helpers
		function drawLinearMask(ctx, w, h, edge) {
			const g = (edge === "left" || edge === "right")
				? ctx.createLinearGradient(0, 0, w, 0)
				: ctx.createLinearGradient(0, 0, 0, h);

			if (edge === "left" || edge === "top") {
				g.addColorStop(0, "rgba(0,0,0,1)");
				g.addColorStop(1, "rgba(0,0,0,0)");
			} else { // right or bottom
				g.addColorStop(0, "rgba(0,0,0,0)");
				g.addColorStop(1, "rgba(0,0,0,1)");
			}
			ctx.fillStyle = g;
			ctx.fillRect(0, 0, w, h);
		}

		function drawCornerLinearMask(ctx, w, h, which) {
			// Create a 2-D alpha mask using blackâ€“transparent gradients
			const gX = ctx.createLinearGradient(0, 0, w, 0);
			const gY = ctx.createLinearGradient(0, 0, 0, h);

			// Horizontal ramp
			if (which === "tl" || which === "bl") {
				gX.addColorStop(0, "rgba(0,0,0,1)");
				gX.addColorStop(1, "rgba(0,0,0,0)");
			} else { // right side
				gX.addColorStop(0, "rgba(0,0,0,0)");
				gX.addColorStop(1, "rgba(0,0,0,1)");
			}

			// Vertical ramp
			if (which === "tl" || which === "tr") {
				gY.addColorStop(0, "rgba(0,0,0,1)");
				gY.addColorStop(1, "rgba(0,0,0,0)");
			} else { // bottom side
				gY.addColorStop(0, "rgba(0,0,0,0)");
				gY.addColorStop(1, "rgba(0,0,0,1)");
			}

			// Multiply the two ramps together using destination-in
			const temp = document.createElement("canvas");
			temp.width = w;
			temp.height = h;
			const tctx = temp.getContext("2d");

			// First ramp
			tctx.fillStyle = gX;
			tctx.fillRect(0, 0, w, h);

			// Multiply with second ramp
			tctx.globalCompositeOperation = "destination-in";
			tctx.fillStyle = gY;
			tctx.fillRect(0, 0, w, h);

			// Draw onto the real mask context
			ctx.drawImage(temp, 0, 0);
		}


		// Wavy edge mask (periodic & orientation-correct)
		function buildWavyMaskCanvas(w, h, edge) {
			const mask = document.createElement("canvas");
			mask.width = w;
			mask.height = h;
			const mctx = mask.getContext("2d");
			const img = mctx.createImageData(w, h);
			const data = img.data;

			const isLR = (edge === "left" || edge === "right");
			const thickness = isLR ? w : h;
			const orthoLen = isLR ? h : w;

			const wav = parseInt(wavinessSlider.value, 10) || 0;
			const amp = Math.min(0.45, (wav / 100) * 0.5) * thickness;
			const wavesBase = Math.max(1, Math.round((wav / 100) * 8)); // integer -> periodic
			const waves2 = wavesBase * 2;
			const TWO_PI = Math.PI * 2;
			let i = 0;

			for (let y = 0; y < h; y++) {
				for (let x = 0; x < w; x++) {
					const t = (isLR ? y : x) / Math.max(1, orthoLen - 1);
					const offs = amp * (0.7 * Math.sin(TWO_PI * wavesBase * t) + 0.3 * Math.sin(TWO_PI * waves2 * t));
					let pos;
					if (edge === "left") pos = x - offs;
					else if (edge === "right") pos = (w - 1 - x) - offs;
					else if (edge === "top") pos = y - offs;
					else pos = (h - 1 - y) - offs;

					let a = 1 - (pos / Math.max(1, thickness));
					a = clamp01(a);
					a = a * a * (3 - 2 * a);
					data[i++] = 255;
					data[i++] = 255;
					data[i++] = 255;
					data[i++] = Math.round(a * 255);
				}
			}
			mctx.putImageData(img, 0, 0);
			return mask;
		}

		// 2-D wavy corner mask using global coordinates for continuous waves
		function buildWavyCornerMaskCanvas(w, h, which, tileW, tileH, offsetX, offsetY) {
			const mask = document.createElement("canvas");
			mask.width = w;
			mask.height = h;
			const ctx = mask.getContext("2d");
			const img = ctx.createImageData(w, h);
			const d = img.data;

			const wav = parseInt(wavinessSlider.value, 10) || 0;
			const ampX = Math.min(0.45, (wav / 100) * 0.5) * w;
			const ampY = Math.min(0.45, (wav / 100) * 0.5) * h;
			const waves = Math.max(1, Math.round((wav / 100) * 8));
			const TWO_PI = Math.PI * 2;
			let i = 0;

			for (let y = 0; y < h; y++) {
				const globalY = y + offsetY;
				const tY = globalY / Math.max(1, tileH - 1);
				const offX = ampX * (0.7 * Math.sin(TWO_PI * waves * tY) + 0.3 * Math.sin(TWO_PI * waves * 2 * tY));

				for (let x = 0; x < w; x++) {
					const globalX = x + offsetX;
					const tX = globalX / Math.max(1, tileW - 1);
					const offY = ampY * (0.7 * Math.sin(TWO_PI * waves * tX) + 0.3 * Math.sin(TWO_PI * waves * 2 * tX));

					// x-ramp orientation
					let posX;
					if (which === "tl" || which === "bl") posX = x - offX; // left seam
					else posX = (w - 1 - x) - offX; // right seam

					// y-ramp orientation
					let posY;
					if (which === "tl" || which === "tr") posY = y - offY; // top seam
					else posY = (h - 1 - y) - offY; // bottom seam

					let ax = 1 - (posX / Math.max(1, w));
					let ay = 1 - (posY / Math.max(1, h));
					ax = clamp01(ax);
					ay = clamp01(ay);
					// smooth and multiply
					ax = ax * ax * (3 - 2 * ax);
					ay = ay * ay * (3 - 2 * ay);
					const a = clamp01(ax * ay);

					d[i++] = 255;
					d[i++] = 255;
					d[i++] = 255;
					d[i++] = Math.round(a * 255);
				}
			}
			ctx.putImageData(img, 0, 0);
			return mask;
		}

		// ---- Perlin Noise Mask Functions ----
		function buildPerlinMaskCanvas(w, h, edge) {
			const mask = document.createElement("canvas");
			mask.width = w;
			mask.height = h;
			const mctx = mask.getContext("2d");
			const img = mctx.createImageData(w, h);
			const data = img.data;

			const isLR = (edge === "left" || edge === "right");
			const thickness = isLR ? w : h;
			const scale = (parseInt(perlinScaleSlider.value, 10) || 50) / 1000;
			const octaves = parseInt(perlinOctavesSlider.value, 10) || 3;
			const amp = 0.45 * thickness; // Amplitude of the noise effect
			let i = 0;

			for (let y = 0; y < h; y++) {
				for (let x = 0; x < w; x++) {
					let noiseVal = 0;
					let frequency = scale;
					let amplitude = 1;
					let maxAmplitude = 0;
					for (let o = 0; o < octaves; o++) {
						noiseVal += perlin.noise(x * frequency, y * frequency) * amplitude;
						maxAmplitude += amplitude;
						amplitude *= 0.5; // persistence
						frequency *= 2; // lacunarity
					}
					noiseVal /= maxAmplitude; // normalize

					const offs = amp * noiseVal;
					let pos;
					if (edge === "left") pos = x - offs;
					else if (edge === "right") pos = (w - 1 - x) - offs;
					else if (edge === "top") pos = y - offs;
					else pos = (h - 1 - y) - offs;

					let a = 1 - (pos / Math.max(1, thickness));
					a = clamp01(a);
					a = a * a * (3 - 2 * a); // smoothstep
					data[i++] = 255;
					data[i++] = 255;
					data[i++] = 255;
					data[i++] = Math.round(a * 255);
				}
			}
			mctx.putImageData(img, 0, 0);
			return mask;
		}

		function buildPerlinCornerMaskCanvas(w, h, which, tileW, tileH, offsetX, offsetY) {
			const mask = document.createElement("canvas");
			mask.width = w;
			mask.height = h;
			const ctx = mask.getContext("2d");
			const img = ctx.createImageData(w, h);
			const d = img.data;

			const scale = (parseInt(perlinScaleSlider.value, 10) || 50) / 1000;
			const octaves = parseInt(perlinOctavesSlider.value, 10) || 3;
			const ampX = 0.45 * w;
			const ampY = 0.45 * h;
			let i = 0;

			const getNoise = (x, y) => {
				let noiseVal = 0, freq = scale, ampl = 1, maxAmpl = 0;
				for (let o = 0; o < octaves; o++) {
					noiseVal += perlin.noise(x * freq, y * freq, o * 10.3) * ampl;
					maxAmpl += ampl;
					ampl *= 0.5;
					freq *= 2;
				}
				return noiseVal / maxAmpl;
			};

			for (let y = 0; y < h; y++) {
				for (let x = 0; x < w; x++) {
					const globalX = x + offsetX;
					const globalY = y + offsetY;

					const noiseVal = getNoise(globalX, globalY);
					const offX = ampX * noiseVal;
					const offY = ampY * noiseVal;

					let posX; // x-ramp orientation
					if (which === "tl" || which === "bl") posX = x - offX;
					else posX = (w - 1 - x) - offX;

					let posY; // y-ramp orientation
					if (which === "tl" || which === "tr") posY = y - offY;
					else posY = (h - 1 - y) - offY;

					let ax = 1 - (posX / Math.max(1, w));
					let ay = 1 - (posY / Math.max(1, h));
					ax = clamp01(ax);
					ay = clamp01(ay);
					ax = ax * ax * (3 - 2 * ax); // smoothstep
					ay = ay * ay * (3 - 2 * ay);
					const a = clamp01(ax * ay);

					d[i++] = 255;
					d[i++] = 255;
					d[i++] = 255;
					d[i++] = Math.round(a * 255);
				}
			}
			ctx.putImageData(img, 0, 0);
			return mask;
		}


		function clamp01(v) {
			return v < 0 ? 0 : (v > 1 ? 1 : v);
		}

		// ---- Preview
		function drawPreview() {
			const rect = previewCanvas.getBoundingClientRect();
			if (rect.width === 0 || rect.height === 0) return;
			previewCanvas.width = rect.width;
			previewCanvas.height = rect.height;

			previewCtx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);

			const sourceCanvas = showTransitionsCheckbox.checked ? transitionOnlyCanvas : finalTileCanvas;
			if (!sourceCanvas) return;

			const pattern = previewCtx.createPattern(sourceCanvas, "repeat");
			previewCtx.save();
			previewCtx.translate(transform.x, transform.y);
			previewCtx.scale(transform.zoom, transform.zoom);
			previewCtx.fillStyle = pattern;

			const fillX = -transform.x / transform.zoom;
			const fillY = -transform.y / transform.zoom;
			const fillW = previewCanvas.width / transform.zoom;
			const fillH = previewCanvas.height / transform.zoom;
			previewCtx.fillRect(fillX, fillY, fillW, fillH);
			previewCtx.restore();
		}
	</script>
</body>

</html>