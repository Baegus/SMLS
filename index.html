<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>SMLS - Seamless Tiling Image Editor</title>
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.6.2/cropper.min.css">
	<style>
		body {
			font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
			display: flex;
			flex-wrap: wrap;
			justify-content: center;
			align-items: flex-start;
			gap: 30px;
			padding: 20px;
			background-color: #f4f5f7;
			color: #172b4d;
			line-height: 1.5;
		}

		body * {
			user-select: none;
		}

		.container {
			background-color: #ffffff;
			border-radius: 8px;
			box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
			padding: 20px;
			width: 100%;
			max-width: 500px;
		}

		#preview-container {
			height: 500px;
			cursor: grab;
			overflow: hidden;
			position: relative;
			border-radius: 4px;
			background-color: #dfe1e6;
			touch-action: none;
			/* Prevents default browser actions like scroll/zoom on touch */
		}

		#preview-container:active {
			cursor: grabbing;
		}

		#preview-canvas {
			display: block;
			width: 100%;
			height: 100%;
		}

		#image-to-crop {
			max-width: 100%;
			display: none;
		}

		#image-to-crop.loaded {
			display: block;
		}

		#drop-zone {
			border: 2px dashed #dfe1e6;
			border-radius: 8px;
			padding: 40px 20px;
			text-align: center;
			cursor: pointer;
			background-color: #fafbfc;
			transition: background-color 0.2s, border-color 0.2s;
		}

		#drop-zone:hover {
			border-color: #0052cc;
			background-color: #eaf2ff;
		}

		.controls,
		.slider-control {
			margin-top: 20px;
		}

		.slider-control {
			display: none;
		}

		#algo-container {
			display: none
		}

		label {
			font-weight: 600
		}

		.slider-control label {
			display: block;
			margin-bottom: 8px
		}

		.slider-control input[type="range"] {
			width: 100%;
			cursor: pointer
		}

		select {
			width: 100%;
			padding: 8px 10px;
			border-radius: 6px;
			border: 1px solid #dfe1e6;
			margin-top: 8px
		}

		button {
			font-size: 14px;
			padding: 10px 16px;
			border: none;
			background-color: #0052cc;
			color: white;
			cursor: pointer;
			border-radius: 5px;
			transition: background-color 0.2s;
		}

		button:disabled {
			background-color: #a5adba;
			cursor: not-allowed;
		}

		button:hover:not(:disabled) {
			background-color: #003b95;
		}
	</style>
</head>

<body>

	<div id="editor-container" class="container">
		<h2>1. Upload & Crop Image</h2>
		<div id="drop-zone">
			<p>Drag & Drop an image here or click</p>
			<input type="file" id="image-input" accept="image/*" style="display: none;">
		</div>

		<div><img id="image-to-crop" alt="Source image for cropping"></div>

		<div id="algo-container" class="controls">
			<label for="blend-mode">Blend Algorithm</label>
			<select id="blend-mode">
				<option value="perlin" selected>Perlin Noise</option>
				<option value="wavy">Wavy gradient</option>
				<option value="linear">Linear gradient</option>
			</select>
		</div>

		<div id="blend-slider-container" class="slider-control">
			<label for="blend-amount">Blend Amount: <span id="blend-value">16</span>%</label>
			<input type="range" id="blend-amount" min="0" max="100" value="16">
		</div>

		<div id="waviness-container" class="slider-control">
			<label for="waviness">Waviness: <span id="waviness-value">35</span>%</label>
			<input type="range" id="waviness" min="0" max="100" value="35">
		</div>

		<div id="perlin-scale-container" class="slider-control">
			<label for="perlin-scale">Noise Scale: <span id="perlin-scale-value">20</span>%</label>
			<input type="range" id="perlin-scale" min="1" max="100" value="20">
		</div>

		<div id="perlin-octaves-container" class="slider-control">
			<label for="perlin-octaves">Noise Detail (Octaves): <span id="perlin-octaves-value">3</span></label>
			<input type="range" id="perlin-octaves" min="1" max="8" value="3">
		</div>


		<div class="controls">
			<button id="download-btn" disabled>Download Tile (PNG)</button>
		</div>
	</div>

	<div class="container">
		<h2>2. Preview (Pan & Zoom)</h2>
		<div id="preview-container">
			<canvas id="preview-canvas"></canvas>
		</div>
		<div class="controls">
			<label>
				<input type="checkbox" id="show-transitions">
				Show transitions only
			</label>
		</div>
	</div>

	<script src="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.6.2/cropper.min.js"></script>
	<script>
		// --- PERLIN NOISE GENERATOR ---
		// Based on implementation by Ken Perlin
		class PerlinNoise {
			constructor() {
				this.p = new Uint8Array(512);
				const permutation = [151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140, 36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23, 190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117, 35, 11, 32, 57, 177, 33, 88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175, 74, 165, 71, 134, 139, 48, 27, 166, 77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133, 230, 220, 105, 92, 41, 55, 46, 245, 40, 244, 102, 143, 54, 65, 25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89, 18, 169, 200, 196, 135, 130, 116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226, 250, 124, 123, 5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17, 182, 189, 28, 42, 223, 183, 170, 213, 119, 248, 152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9, 129, 22, 39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246, 97, 228, 254, 138, 1, 107, 205, 4, 195, 121, 115, 210, 51, 14, 162, 34, 215, 150, 156, 128, 141, 180, 181, 114, 193, 214, 199, 192, 106, 72, 127, 176, 238, 239, 184, 249, 67, 12, 145, 24, 236, 222, 191, 144, 157, 66, 235, 49, 61, 179, 81, 93, 243, 204, 241, 78, 242, 12, 31, 50];
				for (let i = 0; i < 256; i++) this.p[i] = this.p[i + 256] = permutation[i];
			}
			noise(x, y, z = 0) {
				let X = Math.floor(x) & 255,
					Y = Math.floor(y) & 255,
					Z = Math.floor(z) & 255;
				x -= Math.floor(x); y -= Math.floor(y); z -= Math.floor(z);
				let u = this.fade(x), v = this.fade(y), w = this.fade(z);
				let A = this.p[X] + Y,
					AA = this.p[A] + Z,
					AB = this.p[A + 1] + Z,
					B = this.p[X + 1] + Y,
					BA = this.p[B] + Z,
					BB = this.p[B + 1] + Z;
				return this.lerp(w, this.lerp(v, this.lerp(u, this.grad(this.p[AA], x, y, z), this.grad(this.p[BA], x - 1, y, z)),
					this.lerp(u, this.grad(this.p[AB], x, y - 1, z), this.grad(this.p[BB], x - 1, y - 1, z))),
					this.lerp(v, this.lerp(u, this.grad(this.p[AA + 1], x, y, z - 1),
						this.grad(this.p[BA + 1], x - 1, y, z - 1)),
						this.lerp(u, this.grad(this.p[AB + 1], x, y - 1, z - 1), this.grad(this.p[BB + 1], x - 1, y - 1, z - 1))));
			}
			fade(t) { return t * t * t * (t * (t * 6 - 15) + 10); }
			lerp(t, a, b) { return a + t * (b - a); }
			grad(hash, x, y, z) {
				let h = hash & 15;
				let u = h < 8 ? x : y, v = h < 4 ? y : h === 12 || h === 14 ? x : z;
				return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
			}
		}
		const perlin = new PerlinNoise();


		// DOM Elements
		const dropZone = document.getElementById("drop-zone");
		const imageInput = document.getElementById("image-input");
		const imageToCrop = document.getElementById("image-to-crop");
		const downloadBtn = document.getElementById("download-btn");
		const previewCanvas = document.getElementById("preview-canvas");
		const previewCtx = previewCanvas.getContext("2d");
		const showTransitionsCheckbox = document.getElementById("show-transitions");

		const algoContainer = document.getElementById("algo-container");
		const blendModeSelect = document.getElementById("blend-mode");
		const blendSliderContainer = document.getElementById("blend-slider-container");
		const blendSlider = document.getElementById("blend-amount");
		const blendValueSpan = document.getElementById("blend-value");
		const wavinessContainer = document.getElementById("waviness-container");
		const wavinessSlider = document.getElementById("waviness");
		const wavinessValueSpan = document.getElementById("waviness-value");
		const perlinScaleContainer = document.getElementById("perlin-scale-container");
		const perlinScaleSlider = document.getElementById("perlin-scale");
		const perlinScaleValueSpan = document.getElementById("perlin-scale-value");
		const perlinOctavesContainer = document.getElementById("perlin-octaves-container");
		const perlinOctavesSlider = document.getElementById("perlin-octaves");
		const perlinOctavesValueSpan = document.getElementById("perlin-octaves-value");


		// ---- State
		let cropper, finalTileCanvas, transitionOnlyCanvas, sourceImage;
		let transform = { x: 0, y: 0, zoom: 1 };
		let isPanning = false;
		let lastMousePos = { x: 0, y: 0 };
		let initialPinchDistance = null;

		// --- Event Listeners ---
		dropZone.addEventListener("click", () => imageInput.click());
		dropZone.addEventListener("dragover", e => {
			e.preventDefault();
			dropZone.style.borderColor = "#0052cc";
		});
		dropZone.addEventListener("dragleave", () => {
			dropZone.style.borderColor = "#dfe1e6";
		});
		dropZone.addEventListener("drop", e => {
			e.preventDefault();
			dropZone.style.borderColor = "#dfe1e6";
			if (e.dataTransfer.files.length) handleFile(e.dataTransfer.files[0]);
		});
		imageInput.addEventListener("change", e => {
			if (e.target.files.length) handleFile(e.target.files[0]);
		});

		const handleParamChange = () => generateSeamlessTexture();
		blendSlider.addEventListener("input", () => {
			blendValueSpan.textContent = blendSlider.value;
			handleParamChange();
		});
		wavinessSlider.addEventListener("input", () => {
			wavinessValueSpan.textContent = wavinessSlider.value;
			handleParamChange();
		});
		perlinScaleSlider.addEventListener("input", () => {
			perlinScaleValueSpan.textContent = perlinScaleSlider.value;
			handleParamChange();
		});
		perlinOctavesSlider.addEventListener("input", () => {
			perlinOctavesValueSpan.textContent = perlinOctavesSlider.value;
			handleParamChange();
		});


		blendModeSelect.addEventListener("change", () => {
			const mode = blendModeSelect.value;
			wavinessContainer.style.display = mode === "wavy" ? "block" : "none";
			perlinScaleContainer.style.display = mode === "perlin" ? "block" : "none";
			perlinOctavesContainer.style.display = mode === "perlin" ? "block" : "none";
			generateSeamlessTexture();
		});

		downloadBtn.addEventListener("click", () => {
			if (!finalTileCanvas) return;
			const a = document.createElement("a");
			a.download = "seamless-texture.png";
			a.href = finalTileCanvas.toDataURL("image/png");
			a.click();
		});

		// ---- Preview controls (Mouse)
		previewCanvas.addEventListener("wheel", handleZoom, { passive: false });
		previewCanvas.addEventListener("mousedown", e => {
			isPanning = true;
			lastMousePos = { x: e.clientX, y: e.clientY };
		});
		previewCanvas.addEventListener("mousemove", e => {
			if (!isPanning) return;
			const dx = e.clientX - lastMousePos.x, dy = e.clientY - lastMousePos.y;
			transform.x += dx;
			transform.y += dy;
			lastMousePos = { x: e.clientX, y: e.clientY };
			drawPreview();
		});
		previewCanvas.addEventListener("mouseup", () => isPanning = false);
		previewCanvas.addEventListener("mouseleave", () => isPanning = false);

		// ---- Preview controls (Touch)
		previewCanvas.addEventListener("touchstart", e => {
			e.preventDefault();
			if (e.touches.length === 1) {
				isPanning = true;
				lastMousePos = { x: e.touches[0].clientX, y: e.touches[0].clientY };
			} else if (e.touches.length === 2) {
				isPanning = false; // Stop panning for pinch
				const dx = e.touches[0].clientX - e.touches[1].clientX;
				const dy = e.touches[0].clientY - e.touches[1].clientY;
				initialPinchDistance = Math.sqrt(dx * dx + dy * dy);
			}
		}, { passive: false });

		previewCanvas.addEventListener("touchmove", e => {
			e.preventDefault();
			if (e.touches.length === 1 && isPanning) {
				// Pan (1 finger)
				const touch = e.touches[0];
				const dx = touch.clientX - lastMousePos.x;
				const dy = touch.clientY - lastMousePos.y;
				transform.x += dx;
				transform.y += dy;
				lastMousePos = { x: touch.clientX, y: touch.clientY };
				drawPreview();
			} else if (e.touches.length === 2 && initialPinchDistance) {
				// Pinch to Zoom (2 fingers)
				const dx = e.touches[0].clientX - e.touches[1].clientX;
				const dy = e.touches[0].clientY - e.touches[1].clientY;
				const currentDistance = Math.sqrt(dx * dx + dy * dy);
				const scale = currentDistance / initialPinchDistance;

				const rect = previewCanvas.getBoundingClientRect();
				const midX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
				const midY = (e.touches[0].clientY + e.touches[1].clientY) / 2;
				const mX = midX - rect.left;
				const mY = midY - rect.top;

				const oZ = transform.zoom;
				transform.zoom *= scale;
				transform.zoom = Math.max(0.1, Math.min(10, transform.zoom));

				transform.x = mX - (mX - transform.x) * (transform.zoom / oZ);
				transform.y = mY - (mY - transform.y) * (transform.zoom / oZ);

				initialPinchDistance = currentDistance;
				drawPreview();
			}
		}, { passive: false });

		previewCanvas.addEventListener("touchend", e => {
			if (e.touches.length < 2) {
				initialPinchDistance = null;
			}
			if (e.touches.length < 1) {
				isPanning = false;
			}
			// If a pinch ends and one finger remains, start panning from that finger's position
			if (e.touches.length === 1) {
				isPanning = true;
				lastMousePos = { x: e.touches[0].clientX, y: e.touches[0].clientY };
			}
		});


		window.addEventListener("resize", drawPreview);
		showTransitionsCheckbox.addEventListener("change", drawPreview);


		function handleZoom(e) {
			e.preventDefault();
			const scale = 1.1;
			const rect = previewCanvas.getBoundingClientRect();
			const mX = e.clientX - rect.left, mY = e.clientY - rect.top;
			const oZ = transform.zoom;
			transform.zoom *= (e.deltaY < 0 ? scale : 1 / scale);
			transform.zoom = Math.max(0.1, Math.min(10, transform.zoom));
			transform.x = mX - (mX - transform.x) * (transform.zoom / oZ);
			transform.y = mY - (mY - transform.y) * (transform.zoom / oZ);
			drawPreview();
		}

		function handleFile(file) {
			imageToCrop.classList.remove("loaded");
			const reader = new FileReader();
			reader.onload = e => {
				sourceImage = new Image();
				sourceImage.onload = () => {
					imageToCrop.src = e.target.result;
					dropZone.style.display = "none";
					algoContainer.style.display = "block";
					blendSliderContainer.style.display = "block";
					// Show correct sliders for default mode
					const mode = blendModeSelect.value;
					wavinessContainer.style.display = mode === "wavy" ? "block" : "none";
					perlinScaleContainer.style.display = mode === "perlin" ? "block" : "none";
					perlinOctavesContainer.style.display = mode === "perlin" ? "block" : "none";
					downloadBtn.disabled = false;

					if (cropper) cropper.destroy();
					cropper = new Cropper(imageToCrop, { viewMode: 1, background: false, autoCropArea: 0.8, crop: generateSeamlessTexture });
					imageToCrop.classList.add("loaded");
				};
				sourceImage.src = e.target.result;
			};
			reader.readAsDataURL(file);
		}

		// ---- Tile generation
		function generateSeamlessTexture() {
			if (!cropper || !sourceImage) return;

			const cropData = cropper.getData({ rounded: true });
			const canvasData = cropper.getCanvasData();
			const scale = sourceImage.naturalWidth / canvasData.naturalWidth;

			const sx = (cropData.x - canvasData.left) * scale;
			const sy = (cropData.y - canvasData.top) * scale;
			const sWidth = Math.max(1, Math.round(cropData.width * scale));
			const sHeight = Math.max(1, Math.round(cropData.height * scale));

			finalTileCanvas = document.createElement("canvas");
			finalTileCanvas.width = sWidth;
			finalTileCanvas.height = sHeight;
			const tileCtx = finalTileCanvas.getContext("2d");

			transitionOnlyCanvas = document.createElement("canvas");
			transitionOnlyCanvas.width = sWidth;
			transitionOnlyCanvas.height = sHeight;
			const transCtx = transitionOnlyCanvas.getContext("2d");

			// Base crop
			tileCtx.drawImage(sourceImage, sx, sy, sWidth, sHeight, 0, 0, sWidth, sHeight);

			const blendRatio = blendSlider.value / 100;
			if (blendRatio === 0) {
				drawPreview();
				return;
			}

			// Calculate available "excess" pixels on all sides
			const leftExcess = sx;
			const rightExcess = sourceImage.naturalWidth - (sx + sWidth);
			const topExcess = sy;
			const bottomExcess = sourceImage.naturalHeight - (sy + sHeight);

			const horizSide = rightExcess >= leftExcess ? "right" : "left";   // which side we borrow from
			const vertSide = bottomExcess >= topExcess ? "bottom" : "top";

			let blendW = 0, blendH = 0, didHoriz = false, didVert = false;

			// helper: edge patch
			const createAndBlendPatch = (sx_, sy_, w_, h_, dx_, dy_, edge) => {
				if (w_ <= 0 || h_ <= 0) return;
				const patch = document.createElement("canvas");
				patch.width = w_;
				patch.height = h_;
				const pctx = patch.getContext("2d");
				pctx.drawImage(sourceImage, sx_, sy_, w_, h_, 0, 0, w_, h_);
				pctx.globalCompositeOperation = "destination-in";

				const mode = blendModeSelect.value;
				if (mode === "wavy") {
					pctx.drawImage(buildWavyMaskCanvas(w_, h_, edge), 0, 0);
				} else if (mode === "perlin") {
					pctx.drawImage(buildPerlinMaskCanvas(w_, h_, edge), 0, 0);
				} else {
					drawLinearMask(pctx, w_, h_, edge);
				}
				pctx.globalCompositeOperation = "source-over";
				tileCtx.drawImage(patch, dx_, dy_);
				transCtx.drawImage(patch, dx_, dy_);
			};

			// horizontal seam
			if (horizSide === "right" && rightExcess > 0) {
				blendW = Math.floor(Math.min(rightExcess, sWidth / 2) * blendRatio);
				if (blendW > 0) {
					createAndBlendPatch(sx + sWidth, sy, blendW, sHeight, 0, 0, "left");
					didHoriz = true;
				}
			} else if (horizSide === "left" && leftExcess > 0) {
				blendW = Math.floor(Math.min(leftExcess, sWidth / 2) * blendRatio);
				if (blendW > 0) {
					createAndBlendPatch(sx - blendW, sy, blendW, sHeight, sWidth - blendW, 0, "right");
					didHoriz = true;
				}
			}

			// vertical seam
			if (vertSide === "bottom" && bottomExcess > 0) {
				blendH = Math.floor(Math.min(bottomExcess, sHeight / 2) * blendRatio);
				if (blendH > 0) {
					createAndBlendPatch(sx, sy + sHeight, sWidth, blendH, 0, 0, "top");
					didVert = true;
				}
			} else if (vertSide === "top" && topExcess > 0) {
				blendH = Math.floor(Math.min(topExcess, sHeight / 2) * blendRatio);
				if (blendH > 0) {
					createAndBlendPatch(sx, sy - blendH, sWidth, blendH, 0, sHeight - blendH, "bottom");
					didVert = true;
				}
			}

			if (didHoriz && didVert && blendW > 0 && blendH > 0) {
				const corner = document.createElement("canvas");
				corner.width = blendW;
				corner.height = blendH;
				const cctx = corner.getContext("2d");

				// choose diagonal source + destination + which corner
				let srcX, srcY, dstX, dstY, which;
				if (horizSide === "right" && vertSide === "bottom") { // top-left corner uses BR source
					srcX = sx + sWidth;
					srcY = sy + sHeight;
					dstX = 0;
					dstY = 0;
					which = "tl";
				} else if (horizSide === "right" && vertSide === "top") { // bottom-left corner uses TR source
					srcX = sx + sWidth;
					srcY = sy - blendH;
					dstX = 0;
					dstY = sHeight - blendH;
					which = "bl";
				} else if (horizSide === "left" && vertSide === "bottom") { // top-right corner uses BL source
					srcX = sx - blendW;
					srcY = sy + sHeight;
					dstX = sWidth - blendW;
					dstY = 0;
					which = "tr";
				} else { // left & top -> bottom-right corner uses TL source
					srcX = sx - blendW;
					srcY = sy - blendH;
					dstX = sWidth - blendW;
					dstY = sHeight - blendH;
					which = "br";
				}

				cctx.drawImage(sourceImage, srcX, srcY, blendW, blendH, 0, 0, blendW, blendH);
				cctx.globalCompositeOperation = "destination-in";
				const mode = blendModeSelect.value;
				if (mode === "wavy") {
					cctx.drawImage(buildWavyCornerMaskCanvas(blendW, blendH, which, sWidth, sHeight, dstX, dstY), 0, 0);
				} else if (mode === "perlin") {
					cctx.drawImage(buildPerlinCornerMaskCanvas(blendW, blendH, which, sWidth, sHeight, dstX, dstY), 0, 0);
				} else {
					drawCornerLinearMask(cctx, blendW, blendH, which);
				}
				cctx.globalCompositeOperation = "source-over";
				tileCtx.drawImage(corner, dstX, dstY);
				transCtx.drawImage(corner, dstX, dstY);
			}

			drawPreview();
		}

		// ---- Mask helpers
		function drawLinearMask(ctx, w, h, edge) {
			const g = (edge === "left" || edge === "right")
				? ctx.createLinearGradient(0, 0, w, 0)
				: ctx.createLinearGradient(0, 0, 0, h);

			if (edge === "left" || edge === "top") {
				g.addColorStop(0, "rgba(0,0,0,1)");
				g.addColorStop(1, "rgba(0,0,0,0)");
			} else { // right or bottom
				g.addColorStop(0, "rgba(0,0,0,0)");
				g.addColorStop(1, "rgba(0,0,0,1)");
			}
			ctx.fillStyle = g;
			ctx.fillRect(0, 0, w, h);
		}

		function drawCornerLinearMask(ctx, w, h, which) {
			// Create a 2-D alpha mask using black–transparent gradients
			const gX = ctx.createLinearGradient(0, 0, w, 0);
			const gY = ctx.createLinearGradient(0, 0, 0, h);

			// Horizontal ramp
			if (which === "tl" || which === "bl") {
				gX.addColorStop(0, "rgba(0,0,0,1)");
				gX.addColorStop(1, "rgba(0,0,0,0)");
			} else { // right side
				gX.addColorStop(0, "rgba(0,0,0,0)");
				gX.addColorStop(1, "rgba(0,0,0,1)");
			}

			// Vertical ramp
			if (which === "tl" || which === "tr") {
				gY.addColorStop(0, "rgba(0,0,0,1)");
				gY.addColorStop(1, "rgba(0,0,0,0)");
			} else { // bottom side
				gY.addColorStop(0, "rgba(0,0,0,0)");
				gY.addColorStop(1, "rgba(0,0,0,1)");
			}

			// Multiply the two ramps together using destination-in
			const temp = document.createElement("canvas");
			temp.width = w;
			temp.height = h;
			const tctx = temp.getContext("2d");

			// First ramp
			tctx.fillStyle = gX;
			tctx.fillRect(0, 0, w, h);

			// Multiply with second ramp
			tctx.globalCompositeOperation = "destination-in";
			tctx.fillStyle = gY;
			tctx.fillRect(0, 0, w, h);

			// Draw onto the real mask context
			ctx.drawImage(temp, 0, 0);
		}


		// Wavy edge mask (periodic & orientation-correct)
		function buildWavyMaskCanvas(w, h, edge) {
			const mask = document.createElement("canvas");
			mask.width = w;
			mask.height = h;
			const mctx = mask.getContext("2d");
			const img = mctx.createImageData(w, h);
			const data = img.data;

			const isLR = (edge === "left" || edge === "right");
			const thickness = isLR ? w : h;
			const orthoLen = isLR ? h : w;

			const wav = parseInt(wavinessSlider.value, 10) || 0;
			const amp = Math.min(0.45, (wav / 100) * 0.5) * thickness;
			const wavesBase = Math.max(1, Math.round((wav / 100) * 8)); // integer -> periodic
			const waves2 = wavesBase * 2;
			const TWO_PI = Math.PI * 2;
			let i = 0;

			for (let y = 0; y < h; y++) {
				for (let x = 0; x < w; x++) {
					const t = (isLR ? y : x) / Math.max(1, orthoLen - 1);
					const offs = amp * (0.7 * Math.sin(TWO_PI * wavesBase * t) + 0.3 * Math.sin(TWO_PI * waves2 * t));
					let pos;
					if (edge === "left") pos = x - offs;
					else if (edge === "right") pos = (w - 1 - x) - offs;
					else if (edge === "top") pos = y - offs;
					else pos = (h - 1 - y) - offs;

					let a = 1 - (pos / Math.max(1, thickness));
					a = clamp01(a);
					a = a * a * (3 - 2 * a);
					data[i++] = 255;
					data[i++] = 255;
					data[i++] = 255;
					data[i++] = Math.round(a * 255);
				}
			}
			mctx.putImageData(img, 0, 0);
			return mask;
		}

		// 2-D wavy corner mask using global coordinates for continuous waves
		function buildWavyCornerMaskCanvas(w, h, which, tileW, tileH, offsetX, offsetY) {
			const mask = document.createElement("canvas");
			mask.width = w;
			mask.height = h;
			const ctx = mask.getContext("2d");
			const img = ctx.createImageData(w, h);
			const d = img.data;

			const wav = parseInt(wavinessSlider.value, 10) || 0;
			const ampX = Math.min(0.45, (wav / 100) * 0.5) * w;
			const ampY = Math.min(0.45, (wav / 100) * 0.5) * h;
			const waves = Math.max(1, Math.round((wav / 100) * 8));
			const TWO_PI = Math.PI * 2;
			let i = 0;

			for (let y = 0; y < h; y++) {
				const globalY = y + offsetY;
				const tY = globalY / Math.max(1, tileH - 1);
				const offX = ampX * (0.7 * Math.sin(TWO_PI * waves * tY) + 0.3 * Math.sin(TWO_PI * waves * 2 * tY));

				for (let x = 0; x < w; x++) {
					const globalX = x + offsetX;
					const tX = globalX / Math.max(1, tileW - 1);
					const offY = ampY * (0.7 * Math.sin(TWO_PI * waves * tX) + 0.3 * Math.sin(TWO_PI * waves * 2 * tX));

					// x-ramp orientation
					let posX;
					if (which === "tl" || which === "bl") posX = x - offX; // left seam
					else posX = (w - 1 - x) - offX; // right seam

					// y-ramp orientation
					let posY;
					if (which === "tl" || which === "tr") posY = y - offY; // top seam
					else posY = (h - 1 - y) - offY; // bottom seam

					let ax = 1 - (posX / Math.max(1, w));
					let ay = 1 - (posY / Math.max(1, h));
					ax = clamp01(ax);
					ay = clamp01(ay);
					// smooth and multiply
					ax = ax * ax * (3 - 2 * ax);
					ay = ay * ay * (3 - 2 * ay);
					const a = clamp01(ax * ay);

					d[i++] = 255;
					d[i++] = 255;
					d[i++] = 255;
					d[i++] = Math.round(a * 255);
				}
			}
			ctx.putImageData(img, 0, 0);
			return mask;
		}

		// ---- Perlin Noise Mask Functions ----
		function buildPerlinMaskCanvas(w, h, edge) {
			const mask = document.createElement("canvas");
			mask.width = w;
			mask.height = h;
			const mctx = mask.getContext("2d");
			const img = mctx.createImageData(w, h);
			const data = img.data;

			const isLR = (edge === "left" || edge === "right");
			const thickness = isLR ? w : h;
			const scale = (parseInt(perlinScaleSlider.value, 10) || 50) / 1000;
			const octaves = parseInt(perlinOctavesSlider.value, 10) || 3;
			const amp = 0.45 * thickness; // Amplitude of the noise effect
			let i = 0;

			for (let y = 0; y < h; y++) {
				for (let x = 0; x < w; x++) {
					let noiseVal = 0;
					let frequency = scale;
					let amplitude = 1;
					let maxAmplitude = 0;
					for (let o = 0; o < octaves; o++) {
						noiseVal += perlin.noise(x * frequency, y * frequency) * amplitude;
						maxAmplitude += amplitude;
						amplitude *= 0.5; // persistence
						frequency *= 2; // lacunarity
					}
					noiseVal /= maxAmplitude; // normalize

					const offs = amp * noiseVal;
					let pos;
					if (edge === "left") pos = x - offs;
					else if (edge === "right") pos = (w - 1 - x) - offs;
					else if (edge === "top") pos = y - offs;
					else pos = (h - 1 - y) - offs;

					let a = 1 - (pos / Math.max(1, thickness));
					a = clamp01(a);
					a = a * a * (3 - 2 * a); // smoothstep
					data[i++] = 255;
					data[i++] = 255;
					data[i++] = 255;
					data[i++] = Math.round(a * 255);
				}
			}
			mctx.putImageData(img, 0, 0);
			return mask;
		}

		function buildPerlinCornerMaskCanvas(w, h, which, tileW, tileH, offsetX, offsetY) {
			const mask = document.createElement("canvas");
			mask.width = w;
			mask.height = h;
			const ctx = mask.getContext("2d");
			const img = ctx.createImageData(w, h);
			const d = img.data;

			const scale = (parseInt(perlinScaleSlider.value, 10) || 50) / 1000;
			const octaves = parseInt(perlinOctavesSlider.value, 10) || 3;
			const ampX = 0.45 * w;
			const ampY = 0.45 * h;
			let i = 0;

			const getNoise = (x, y) => {
				let noiseVal = 0, freq = scale, ampl = 1, maxAmpl = 0;
				for (let o = 0; o < octaves; o++) {
					noiseVal += perlin.noise(x * freq, y * freq, o * 10.3) * ampl;
					maxAmpl += ampl;
					ampl *= 0.5;
					freq *= 2;
				}
				return noiseVal / maxAmpl;
			};

			for (let y = 0; y < h; y++) {
				for (let x = 0; x < w; x++) {
					const globalX = x + offsetX;
					const globalY = y + offsetY;

					const noiseVal = getNoise(globalX, globalY);
					const offX = ampX * noiseVal;
					const offY = ampY * noiseVal;

					let posX; // x-ramp orientation
					if (which === "tl" || which === "bl") posX = x - offX;
					else posX = (w - 1 - x) - offX;

					let posY; // y-ramp orientation
					if (which === "tl" || which === "tr") posY = y - offY;
					else posY = (h - 1 - y) - offY;

					let ax = 1 - (posX / Math.max(1, w));
					let ay = 1 - (posY / Math.max(1, h));
					ax = clamp01(ax);
					ay = clamp01(ay);
					ax = ax * ax * (3 - 2 * ax); // smoothstep
					ay = ay * ay * (3 - 2 * ay);
					const a = clamp01(ax * ay);

					d[i++] = 255;
					d[i++] = 255;
					d[i++] = 255;
					d[i++] = Math.round(a * 255);
				}
			}
			ctx.putImageData(img, 0, 0);
			return mask;
		}


		function clamp01(v) {
			return v < 0 ? 0 : (v > 1 ? 1 : v);
		}

		// ---- Preview
		function drawPreview() {
			const rect = previewCanvas.getBoundingClientRect();
			if (rect.width === 0 || rect.height === 0) return;
			previewCanvas.width = rect.width;
			previewCanvas.height = rect.height;

			previewCtx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);

			const sourceCanvas = showTransitionsCheckbox.checked ? transitionOnlyCanvas : finalTileCanvas;
			if (!sourceCanvas) return;

			const pattern = previewCtx.createPattern(sourceCanvas, "repeat");
			previewCtx.save();
			previewCtx.translate(transform.x, transform.y);
			previewCtx.scale(transform.zoom, transform.zoom);
			previewCtx.fillStyle = pattern;

			const fillX = -transform.x / transform.zoom;
			const fillY = -transform.y / transform.zoom;
			const fillW = previewCanvas.width / transform.zoom;
			const fillH = previewCanvas.height / transform.zoom;
			previewCtx.fillRect(fillX, fillY, fillW, fillH);
			previewCtx.restore();
		}
	</script>
</body>

</html>